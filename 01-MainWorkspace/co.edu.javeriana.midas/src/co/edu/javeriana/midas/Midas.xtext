grammar co.edu.javeriana.midas.Midas 
with org.eclipse.xtext.common.Terminals

import "http://www.edu.co/javeriana/midas/Midas"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Package: 
	{Package}
	'Package'  name=QualifiedName ';'
	imports+=Import*
	subComponents+=Component*;

Import returns Import:
	{Import}
	'import' 
	importedNamespace=QualifiedNameWithWildcard ';';

Component returns Component:
	Class_Impl | Context | Format | User | 
	Primitive | Requirement | FunctionCall | 
	FunctionDefinition | System | ModalOperator |
	RequirementAction | Enum | Association | 
	Assignment | Variable;

System returns System:
	{System}
	'System' '{'
	name=QualifiedName ':' description=STRING
	'}';

Variable returns Variable:
	{Variable}
	type=Type name=QualifiedName (';')?;

Assignment returns Assignment:
	{Assignment}
	variable=[Variable] '=' expression+=Expression;

FunctionDefinition:
	'function' name=QualifiedName
	'('
	('in' inputVars+=Variable (',' 'in' inputVars+=Variable)* (',' 'out' outputVars+=Variable (',' 'out'
	outputVars+=Variable)*)?)?
	')'
	'{'
	subComponents+=Component*
	'}';

FunctionCall:
	(outputVarReferences+=VarReference '<-')? callee=[FunctionDefinition] '(' (inputVarReferences+=VarReference (','
	inputVarReferences+=VarReference)*)? ')' ';';

VarReference:
	name=QualifiedName ('[' connectedPort=[VarReference] ']')?;

Enum:
	'Enum' name=QualifiedName '{' enumItems+=EnumItem (',' enumItems+=EnumItem)* '}';

EnumItem:
	name=QualifiedName;

Association:
	source=[Class] '[' sourceCardinality=STRING ':' sourceName=QualifiedName ']' name=QualifiedName target=[Class] '['
	targetCardinality=STRING ':' targetName=QualifiedName ']' (memberEnd=Attribute)? ';';

RequirementAction returns RequirementAction:
	'Requirement_action:' name=QualifiedName ';';

ModalOperator:
	'Modal_operator:' name=QualifiedName ';';

Expression:
	BoolTerm ({BinaryOperator.left=current} symbol='match' right=BoolTerm)*;

BoolTerm returns Expression:
	Negation ({BinaryOperator.left=current} (symbol='&&' | symbol='||') right=Negation)*;

Negation returns Expression:
	Comparison | {UnaryOperator} symbol='!' expression=Negation;

Comparison returns Expression:
	ArithmeticExpression ({BinaryOperator.left=current} (symbol='<=' | symbol='>=' | symbol='>' | symbol='<' | symbol='!='
	| symbol='==' | symbol='is' | symbol='as') right=ArithmeticExpression)*;

ArithmeticExpression returns Expression:
	Term ({BinaryOperator.left=current} (symbol='+' | symbol='-') right=Term)*;

Term returns Expression:
	Negative ({BinaryOperator.left=current} (symbol='*' | symbol='/' | symbol='%') right=Negative)*;

Negative returns Expression:
	Factor | {UnaryOperator} '-' expression=Negative;

Factor returns Expression:
	'(' Expression ')' | LiteralValue | Variable;

NumericValue:
	value=INT;

StringValue:
	value=STRING;

LiteralValue:
	NumericValue | StringValue;

//Expression returns Expression:
//	StringValue | NumericValue | Variable;

Requirement:
	'Requirement' name=QualifiedName ':' description=STRING '{'
	roles+=[Role] modaloperator=[ModalOperator] requirementactions+=[RequirementAction] basedOn+=[Reference|QualifiedName] ('profile')?
	('and' requirementactions+=[RequirementAction] basedOn+=[Reference|QualifiedName] ('profile')?)?
	('based' 'on' basedOn+=[Reference|QualifiedName] ('profile')? (',' basedOn+=[Reference|QualifiedName] ('profile')?)*)? 
	'}'
;

Class returns Class:
	Class_Impl | User | Context;

Class_Impl returns Class:
	{Class}
	'Class' name=QualifiedName ('extends' superClass+=[Class|QualifiedName] (',' superClass+=[Class|QualifiedName])*)?
	'{'
	attributes+=Attribute*
	'}';

Format returns Format:
	{Format}
	'Format' name=QualifiedName
	'{'
	attributes+=Attribute*
	'}';

User returns User:
	{User}
	'User' name=QualifiedName
	'{'
	attributes+=Attribute*
	'}';

Context returns Context:
	{Context}
	'Context' name=QualifiedName
	'{'
	attributes+=Attribute*
	'}';

Attribute returns Attribute:
	{Attribute}
	type=Type name=QualifiedName;

Type returns Type:
	Type_Impl | ParameterizedType | SimpleType;

Type_Impl returns Type:
	{Type}
	'type' name=QualifiedName;

SimpleType returns SimpleType:
	{SimpleType}
	typespecification=[TypeSpecification|QualifiedName];

TypeSpecification returns TypeSpecification:
	Primitive | Class;

Primitive returns Primitive:
	{Primitive}
	'Primitive' name=QualifiedName ';';

ParameterizedType:
	typespecification=[TypeSpecification|QualifiedName] => '<' typeParameters+=Type (',' typeParameters+=Type)* '>';

QualifiedName:
	//ID ('.' ID)*;
	ID (('.' | 's') ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'; 