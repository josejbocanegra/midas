/*
 * generated by Xtext 2.9.1
 */
package co.edu.javeriana.midas.scoping

import org.eclipse.emf.ecore.EReference

import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.emf.ecore.EObject

import java.util.HashSet
import co.edu.javeriana.midas.midas.Attribute
import org.eclipse.xtext.scoping.Scopes

import co.edu.javeriana.midas.midas.Reference

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */ 

public class MidasScopeProvider extends AbstractDeclarativeScopeProvider {
	/*def scope_Reference_tail (Port port, EReference ref){
		var Reference reference=port.value.cast(Reference).referencedElement
		var PortDefinition portDefinition = reference.cast(PortDefinition)
		var TypeSpecification typeSpec=portDefinition.type.typespecification
		var co.edu.javeriana.midas.midas.Class _class = typeSpec.cast(co.edu.javeriana.midas.midas.Class)
		
		val opposites = new HashSet<Attribute>
		for (op : _class.attributes) {
			opposites.add(op)
		}
		return Scopes::scopeFor(opposites)
	}*/
	
	/*  -->Este está funcionando -> Ajustar según necesidad
	 
	def scope_Reference_attribute (Reference descr, EReference ref){
		System.out.println("S C O P E");
		val attributes = new HashSet<Attribute>
		if (descr.variable.type instanceof ParameterizedType) {
			var TypeSpecification typeSpec= descr.variable.type.cast(ParameterizedType).typeParameters.get(0).typespecification
			var co.edu.javeriana.midas.midas.Class _class = typeSpec.cast(co.edu.javeriana.midas.midas.Class)
			System.out.println("Class: " + _class.attributes);
			for (op : _class.attributes) {
				attributes.add(op)
			}
		}
		else{
			var TypeSpecification typeSpec= descr.variable.type.typespecification
			var co.edu.javeriana.midas.midas.Class _class = typeSpec.cast(co.edu.javeriana.midas.midas.Class)
			System.out.println("Class: " + _class.attributes);
			for (op : _class.attributes) {
				attributes.add(op)
			}
		}
		//System.out.println("Type: " + descr.variable.type)
		return Scopes::scopeFor(attributes)
	}
	*/
	
	def scope_RequirementDescription_tail (co.edu.javeriana.midas.midas.Class descr, EReference ref){
		System.out.println("S C O P E "+ descr);
	}
	
	def scope_Reference_attribute (Reference reference, EReference ref){
		val attHash = new HashSet<Attribute>
		for (att : reference.class_.attributes) {
			attHash.add(att)
		}
		System.out.println("S C O P E "+ reference.class_);
		return Scopes::scopeFor(attHash)
	}
	
	def <S extends EObject, T extends S> cast(S obj, Class<T> c) {
					return obj as T
	}
	
	/*override IScope getScope(EObject context, EReference reference){
		if(reference==MidasPackage.Literals.REF__ATTRIBUTE){
		
		}
		super.getScope(context, reference);
	}*/
}
